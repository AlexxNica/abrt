#!/usr/bin/python -u
# WARNING: python -u means unbuffered I/O. Without it the messages are
# passed to the parent asynchronously which looks bad in clients.
#
# This script wraps reporter-ureport client and keeps number of sent
# uReports to a server consistent with number of problem ocurrences.

import sys
import os
import getopt

from report import (dd_opendir,
                    DD_FAIL_QUIETLY_ENOENT,
                    run_event_state,
                    EXIT_STOP_EVENT_RUN,
                    load_app_conf_file)
from reportclient import _, set_verbosity, error_msg_and_die, error_msg, log1, log

GETTEXT_PROGNAME = "abrt"
import locale
import gettext

_ = lambda x: gettext.lgettext(x)

def init_gettext():
    try:
        locale.setlocale(locale.LC_ALL, "")
    except locale.Error:
        os.environ['LC_ALL'] = 'C'
        locale.setlocale(locale.LC_ALL, "")
    # Defeat "AttributeError: 'module' object has no attribute 'nl_langinfo'"
    try:
        gettext.bind_textdomain_codeset(GETTEXT_PROGNAME, locale.nl_langinfo(locale.CODESET))
    except AttributeError:
        pass
    gettext.bindtextdomain(GETTEXT_PROGNAME, '/usr/share/locale')
    gettext.textdomain(GETTEXT_PROGNAME)

from problem import SHORTENED_REPORTING

def conf_to_bool(opt_val):
    return opt_val and opt_val.lower() in ["yes", "on", "1"]

def spawn_and_wait(prog, *args):
    try:
        return os.spawnlp(os.P_WAIT, prog, prog, *args)
    except OSError as err:
        error_msg(_("Unable to start '%s', error message was: '%s'"),
                    prog, err)
        return -1

def try_parse_number(dd, filename):
    try:
        n = dd.load_text(filename, DD_FAIL_QUIETLY_ENOENT)
        if n == "":
            return 0
        return int(n)
    except:
        error_msg(_("Not a number in file '%s'"), filename)
        return 0

def get_bugzilla_reports(reported_to):
    bugs = set()
    for line in reported_to.split("\n"):
        if line.startswith("Bugzilla:"):
            bugs.add(line)
    return bugs

def get_bthashes(reported_to):
    bthashes = set()
    for line in reported_to.split("\n"):
        if line.startswith("uReport: BTHASH="):
            bthashes.add(line.split("=")[1])
    return bthashes

def run_event(event_name, dump_dir_name):
    state = run_event_state()
    ret = state.run_event_on_dir_name(dump_dir_name, event_name)
    if ret == 0 and state.children_count == 0:
        log1("Didn't find definition of event '%s'", event_name)

def attach_comment_to_ureport(dump_dir_name):
    noninteractive = os.getenv("REPORT_CLIENT_NONINTERACTIVE") or ""
    if conf_to_bool(noninteractive):
        log1("Current event run is non-interactive: not submitting comment");
        return

    dd = dd_opendir(dump_dir_name, 0)
    if not dd:
        return

    reported_to = dd.load_text("reported_to", DD_FAIL_QUIETLY_ENOENT)
    comment = dd.load_text("comment", DD_FAIL_QUIETLY_ENOENT)
    dd.close()

    if not comment:
        return

    if not reported_to or not get_bthashes(reported_to):
        return

    log(_("Submitting anonymous comment to the ABRT Server"))
    exitcode = spawn_and_wait("reporter-ureport", "-A", "-O")
    if exitcode != 0:
        log1("reporter-ureport failed with exit code %d" % exitcode)


if __name__ == "__main__":
    # localization
    init_gettext()

    verbose = 0
    ABRT_VERBOSE = os.getenv("ABRT_VERBOSE")
    if ABRT_VERBOSE:
        try:
            verbose = int(ABRT_VERBOSE)
        except:
            pass

    progname = os.path.basename(sys.argv[0])
    help_text = _("Usage: %s [-v]") % progname
    try:
        opts, args = getopt.getopt(sys.argv[1:], "vh", ["help"])
    except getopt.GetoptError, err:
        error_msg(err)  # prints something like "option -a not recognized"
        error_msg_and_die(help_text)

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print help_text
            sys.exit(0)
        if opt == "-v":
            verbose += 1

    set_verbosity(verbose)

    # getcwd might fail if cwd was deleted
    try:
        dirname = os.getcwd()
    except OSError as err:
        error_msg_and_die(_("Unable to get current working directory as"
                            " it was probably deleted"))

    dd = dd_opendir(dirname, 0)
    if not dd:
        sys.exit(1)

    report_type = dd.load_text("type", DD_FAIL_QUIETLY_ENOENT)

    # because of backward compatibility
    if not report_type:
        report_type = dd.load_text("analyzer", 0)

    core_backtrace_exists = dd.exist("core_backtrace")
    reported_to = dd.load_text("reported_to", DD_FAIL_QUIETLY_ENOENT)
    ureports_counter = try_parse_number(dd, "ureports_counter")
    count = try_parse_number(dd, "count")
    dd.close()

    default_exitcode = 0

    appconf = {}
    try:
        appconf = load_app_conf_file("abrt-applet")
    except OSError as ex:
        log1("Configuration 'abrt-applet' not loaded: {0}".format(ex.message))

    if conf_to_bool(appconf.get("ShortenedReporting",
                "yes" if SHORTENED_REPORTING else "no")):
        default_exitcode = EXIT_STOP_EVENT_RUN

    # Send only if the problem is not yet reported
    #           if the count file is corrupted or
    #           if the number of ureports is lower then the number of occurrences
    if ureports_counter != 0 and count != 0 and ureports_counter >= count:
        log1("uReport has been already sent: '%s'", dirname)
        if reported_to and reported_to != "":
            bugs = get_bugzilla_reports(reported_to)
            if bugs:
                log(_("A bug was already filed about this problem:"))
                bugs = sorted(bugs)
                for bug in bugs:
                    print bug
                default_exitcode = EXIT_STOP_EVENT_RUN
            else:
                log1("Bug for '%s' not yet filed. Continuing.", dirname)
        else:
            log1("'%s/reported_to' doesn't exist", dirname)

        # we need to attach comment also here becuase the first
        # run of this script was performed in non-interactive mode
        # from abrt-applet or abrtd when comment is not yet available
        attach_comment_to_ureport(dirname)

        sys.exit(default_exitcode)

    if report_type == "CCpp" and not core_backtrace_exists:
        exitcode = spawn_and_wait("abrt-action-generate-core-backtrace")
        if exitcode != 0:
            log1("uReport can't be sent without core_backtrace. Exiting.")
            sys.exit(1)

    exitcode = spawn_and_wait("reporter-ureport")
    if exitcode == 0 or exitcode == EXIT_STOP_EVENT_RUN:
        dd = dd_opendir(dirname, 0)
        if not dd:
            sys.exit(1)
        dd.save_text("ureports_counter", str(ureports_counter + 1))
        reported_to = dd.load_text("reported_to", DD_FAIL_QUIETLY_ENOENT)
        dd.close()

        attach_comment_to_ureport(dirname)

        watch = os.getenv("uReport_WatchReportedBugs") or ""
        if exitcode == EXIT_STOP_EVENT_RUN and conf_to_bool(watch):
            if reported_to and reported_to != "" and get_bugzilla_reports(reported_to):
                log(_("Adding you to CC List of the existing bugzilla bug"))
                run_event("watch_Bugzilla", dirname)

        sys.exit(default_exitcode if exitcode == 0 else exitcode)
    else:
        error_msg_and_die(_("reporter-ureport failed with exit code %d" % exitcode))
