This document describes how to create your own plugin for abrt.

Although a base abstract class CPlugin exists, you can't inherit
directly from it. You must use one of the four subclasses,
depending on what you want your plugin to do.

The subclasses are:
    * Action plugin (CAction)
    * Analyzer plugin (CAnalyzer)
    * Reporter plugin (CReporter)
    * Database plugin (CDatabase)

Each of them requires you to override a different set of methods.

The pDebugDumpDir parameter is very common: it specifies the directory
that is created to gather information of this specific crash.
The files that were created when the application crashed (such as core dumps)
are all stored here. In addition, the plugins can write
their output files there, if any.

Plugin types in detail:


Action Plugin
-------------
This type of plugin is useful when you need some action to be performed
immediately when a crash is encountered (using ActionsAndReporters = ...
directive in abrt.conf), or if you need some action to be performed
periodically ([Cron] section in the same file).

You have to override one method:

virtual void Run(const char *dir, const char *args);

The first argument is a directory that contains the current debug
dump, or all debug dumps for periodic actions.
The second argument is a string with arguments (specified in config file).


Analyzer Plugin
---------------
This plugin has to compute the UUID of the crash. Crashes differ, depending on
where they occur, for example crashes in the kernel differ from crashes in
userspace binaries, which differ from crashes in python scripts. Therefore,
you need a plugin for each type of application that you want abrt to handle.

You have to override these methods:

virtual std::string GetLocalUUID(const std::string& pDebugDumpPath);
- This method computes the local UUID of the crash.

virtual std::string GetGlobalUUID(const std::string& pDebugDumpPath);
- This method computes the global UUID of the crash.

{something is fishy here}

NOTE: The difference between local and global UUID is that the local UUID
is specific for the machine architecture on which the crash is encountered.
When the crash is reported, abrt has to use the "-debuginfo" packages
to render a global UUID, which should be independent of the specific
system (the same crash on different architectures/configurations can
yield different local UUIDs but has to have the same global UUID).

virtual void CreateReport(const std::string& pDebugDumpPath);
- This method creates the report about the crash and stores it
  in the crash's directory.


Reporter Plugin
---------------
This plugin receives the entire finished crash report and
posts/reports it somewhere (e.g. logs it, mails it, posts
it on some web tool...)

You have to override this method:

virtual void Report(const map_crash_data_t& pCrashData,
                    const char *pArgs);
-It is self-explanatory, that this method takes the report
 and presents it somewhere to the world.
 The second argument is a string with arguments specified for the reporter.


Database Plugin
---------------
You use this plugin to store the metadata about the crash. The metadata
has to be in a database, to distinguish whether the current crash is or
is not the same as some crash before. The database can be local, or in
some centralized location on the network.

you have to override these methods:
virtual void Connect();
virtual void DisConnect();
- connect and disconnect from the database

virtual void Insert(const std::string& pUUID,
                    const std::string& pUID,
                    const std::string& pDebugDumpPath,
                    const std::string& pTime);
- insert an entry into the database: you use both UID (user ID) and UUID
  (ID of the crash)

virtual void Delete(const std::string& pUUID, const std::string& pUID);
- delete an entry

virtual void SetReported(const std::string& pUUID, const std::string& pUID);
- insert information into the database to say that this bug was already
  reported (so for example the report plugins won't run several times
  for the same bug)

virtual const vector_database_rows_t GetUIDData(const std::string& pUID);
- get database rows for the specified user ID

virtual const database_row_t GetUUIDData(const std::string& pUUID, const
 std::string& pUID);
- get a database row for the specified user ID and UUID


The macro PLUGIN_INFO
---------------------
Use the macro PLUGIN_INFO in the *.cpp file of your plugin so that your
subclass will be properly registered and treated as a plugin.
This sets up all the lower-level and administrative details to fit your
class into the plugin infrastructure. The syntax is:

PLUGIN_INFO(type, plugin_class, name, version, description, email, www)
- "type" is one of ANALYZER, ACTION, REPORTER, or DATABASE
- "plugin_class" is the identifier of the class
- "name" is a string with the name of the plugin
- "version" is a string with the version of the plugin
- "description" is a string with the summary of what the plugin does
- "email" and "www" are strings with the contact info for the author

For example:
PLUGIN_INFO(REPORTER,
            CMailx,
            "Mailx",
            "0.0.1",
            "Sends an email with a report via mailx command",
            "zprikryl@redhat.com",
            "https://fedorahosted.org/crash-catcher/wiki");
